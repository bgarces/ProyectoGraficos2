<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Principal</title>

    <!-- Bootstrap -->
    <link href="../bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="../bootstrap/css/mycss.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div id="opengl_phong" class="text-center"></div>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../bootstrap/js/bootstrap.min.js"></script>
    <script src="../build_stats/dat.gui.js"></script>
    <script src="../build_stats/stats.min.js"></script>
    <script src="../src_tree/three.min.js"></script>
    <script type="text/javascript">
      $(function () {
        init_phong();
      });
      //funcion del phong shading
      function init_phong(){
        var stats = initStats();
            // create a scene, that will hold all our elements such as objects, cameras and lights.
            var scene = new THREE.Scene();

            // create a camera, which defines where we're looking at.
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // create a render and set the size
            var renderer = new THREE.WebGLRenderer();

            renderer.setClearColorHex(0xFFFFFF, 1.0);
            renderer.setSize(1024, 500);
            renderer.shadowMapEnabled = true;

            // create the ground plane
            var planeGeometry = new THREE.PlaneGeometry(140,140,1,1);
            var planeMaterial =    new THREE.MeshLambertMaterial({color: 0xffffff});
            var plane = new THREE.Mesh(planeGeometry,planeMaterial);
            plane.receiveShadow  = true;

            // rotate and position the plane
            plane.rotation.x=-0.55*Math.PI;
            plane.position.x=15
            plane.position.y=0
            plane.position.z=0

            // add the plane to the scene
            scene.add(plane);

            // creando el cubo 
            var cubeGeometry = new THREE.CubeGeometry(9,9,9);
            var cubeMaterial = new THREE.MeshPhongMaterial ({color: 0xff0000});
            var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.castShadow = true;
            // posición del cubo
            cube.position.x=0;
            cube.position.y=10;
            cube.position.z=0;
            // adiriendolo a la escena
            scene.add(cube);


            //crando la esfera
            var sphereGeometry = new THREE.SphereGeometry(5,32,32);
            var sphereMaterial = new THREE.MeshPhongMaterial ({color: 0x7777ff});
            var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);
            // posición de la esfera 
            sphere.position.x=0;
            sphere.position.y=10;
            sphere.position.z=0;
            sphere.castShadow=true;
            // adiriendolo a la escena 
            scene.add(sphere);

            //creando el toroide
            var geometry = new THREE.TorusGeometry( 5, 2, 16, 100 );
            var materialtoro = new THREE.MeshPhongMaterial ( { color: 0xFFFF00 } );
            var toroide = new THREE.Mesh( geometry, materialtoro );
            //posición del toroide
            toroide.position.x=0;
            toroide.position.y=10;
            toroide.position.z=-0;
            toroide.castShadow=true;
            //adiriendo el toroide a la escena
            scene.add(toroide);

            //creando la pirámide
            var piramideGeometria = new THREE.CylinderGeometry(0,6, 20, 4, 4, true);
            var piramideMaterial = new THREE.MeshPhongMaterial ( { color: 0x20E9C4} );
            for(i = 0; i < piramideGeometria.faces.length; i++){
                piramideGeometria.faces[i].vertexColors[0] = new THREE.Color(0x00FF00);
                piramideGeometria.faces[i].vertexColors[1] = new THREE.Color(0x00FF00);
                piramideGeometria.faces[i].vertexColors[2] = new THREE.Color(0x00FF00);
            }
            //posición inicial de la piramide 
            var piramide = new THREE.Mesh(piramideGeometria, piramideMaterial);
            piramide.position.x=0;
            piramide.position.y=10;
            piramide.position.z=0;
            piramide.castShadow=true;
            scene.add(piramide);

            //tetera
            var loader = new THREE.JSONLoader();
            var tetera;
              loader.load( "Teapot.js", function(geometry){
                var material = new THREE.MeshPhongMaterial ({color: 0x55B663});
                tetera = new THREE.Mesh(geometry, material);
            });
            loader.onLoadComplete=function(){
                tetera.scale.set(5, 5, 5 );
                tetera.position.x=0;
                tetera.position.y=0;
                tetera.position.z=0;
                //tetera.rotation.x=-0.55*Math.PI;
                scene.add( tetera );
                render_tetera();
            }
            // position and point the camera to the center of the scene
            camera.position.x = -30;
            camera.position.y = 80;
            camera.position.z = 30;
            camera.lookAt(scene.position);

            // add subtle ambient lighting
            var ambientLight = new THREE.AmbientLight(0x0c0c0c);
            scene.add(ambientLight);

            // add spotlights for the shadows 
            var spotLight1 = new THREE.SpotLight( 0xffffff );
            spotLight1.position.set( -60, 150, 0 );
            spotLight1.castShadow = true;
            scene.add( spotLight1 );
            var spotLight2 = new THREE.SpotLight( 0xE3E300 );
            spotLight2.position.set( -30, 150, 0 );
            spotLight2.castShadow = true;
            scene.add( spotLight2 );
            var spotLight3 = new THREE.SpotLight( 0xE30000 );
            spotLight3.position.set( -0, 150, 0 );
            spotLight3.castShadow = true;
            scene.add( spotLight3 );
            var spotLight4 = new THREE.SpotLight( 0xAA00E3 );
            spotLight4.position.set( 30, 150, 0 );
            spotLight4.castShadow = true;
            scene.add( spotLight4 );

            // add the output of the renderer to the html element
            $("#opengl_phong").append(renderer.domElement);

            //ángulo de moviemiento inicial de cada figura. 
            var stepcube=0.02;
            var stepesphera=0.018;
            var steptoroide=0.015;
            var steppiramide=0.010;
            //controles de la gui para las luces
            var controls = new function() {
                this.light1 = true;
                this.light2 = true;
                this.light3 = true;
                this.light4 = true;
            }

            var gui = new DAT.GUI();
            gui.add(controls,'light1');
            gui.add(controls,'light2');
            gui.add(controls,'light3');
            gui.add(controls,'light4');


            render();
            function render_tetera() {

              // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/;
              tetera.rotation.y+=-0.01;
              // Render the scene.
              renderer.render(scene, camera);
              requestAnimationFrame(render_tetera);

            }
            function render() {
                //moviemiento circular del cubo
                stepcube+=0.02; //angulo y razón con el que se desplaza 
                cube.position.x = 0+( 20*(Math.cos(stepcube))*1);
                cube.position.z = 0 +( 20*(Math.sin(stepcube))*1);
                cube.rotation.y+=0.03; //rotación

                //moviemiento circular de la esfera
                stepesphera+=0.019;
                sphere.position.x=(30*(Math.cos(stepesphera))*1);
                sphere.position.z=(30*(Math.sin(stepesphera))*1);
                sphere.rotation.y+=0.03;

                //moviemiento circular del toroide
                steptoroide+=0.018;
                toroide.position.x=(40*(Math.cos(steptoroide))*1);
                toroide.position.z=(40*(Math.sin(steptoroide))*1);
                toroide.rotation.y+=0.03;

                //moviemiento circular de la pirámide
                steppiramide+=0.017;
                piramide.position.x=(50*(Math.cos(steppiramide))*1);
                piramide.position.z=(50*(Math.sin(steppiramide))*1);
                piramide.rotation.y+=0.03;
                //encendido y apagado de las luces segun se escoja
                if (!controls.light1) {scene.remove(spotLight1);} else{scene.add(spotLight1)};
                if (!controls.light2) {scene.remove(spotLight2);} else{scene.add(spotLight2)};
                if (!controls.light3) {scene.remove(spotLight3);} else{scene.add(spotLight3)};
                if (!controls.light4) {scene.remove(spotLight4);} else{scene.add(spotLight4); };


                //llamada al render
                requestAnimationFrame(render);
                //graficación con las nuevas posiciones
                renderer.render(scene, camera);
            }
            function initStats() {

            var stats = new Stats();

            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'relative';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            $("#stats").append( stats.domElement );

            return stats;
        }


    }
    </script>
  </body>
</html>